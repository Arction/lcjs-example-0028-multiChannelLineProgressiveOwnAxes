(self.webpackChunk=self.webpackChunk||[]).push([[143],{138:(e,t,n)=>{const s=n(475),o=new Array(5).fill(0).map(((e,t)=>({title:`Ch ${t+1}`}))),{lightningChart:a,AutoCursorModes:i,emptyLine:r,AxisTickStrategies:l,AxisScrollStrategies:c,synchronizeAxisIntervals:h,UIOrigins:g,UIDraggingModes:d,LegendBoxBuilders:m,Themes:u}=s,M=document.getElementById("chart")||document.body,f=a().Dashboard({numberOfColumns:1,numberOfRows:o.length}).setSplitterStyle(r);requestAnimationFrame((()=>{const e=(M.getBoundingClientRect().height-30-40)/o.length;o.forEach(((t,n)=>{const s=e+(0===n?40:0)+(n===o.length-1?30:0);f.setRowHeight(n,s)}))}));const S=o.map(((e,t)=>{const n=f.createChartXY({columnIndex:0,rowIndex:t}).setTitle("").setPadding({top:t>0?6:0,bottom:t<o.length-1?6:0,left:0}).setAutoCursorMode(i.disabled).setBackgroundStrokeStyle(r).setMouseInteractions(!1),s=n.getDefaultAxisX().setTickStrategy(l.Empty).setStrokeStyle(r).setScrollStrategy(c.progressive).setInterval({start:-3e4,end:0,stopAxisAfter:!1}),a=n.getDefaultAxisY().setTickStrategy(l.Empty).setStrokeStyle(r).setTitle(e.title).setTitleRotation(0).setThickness(60),h=n.addLineSeries({dataPattern:{pattern:"ProgressiveX"},automaticColorIndex:t}).setName(`Channel ${t+1}`).setDataCleaning({minDataPointCount:1e4}).setStrokeStyle((e=>e.setThickness(2)));return{chart:n,series:h,axisX:s,axisY:a}})),x=S[0],p=S[S.length-1];x.chart.setTitle(`Multi-channel real-time monitoring (${o.length} chs, 1000 Hz)`);const y=p.axisX.setThickness(30).setTickStrategy(l.Time,(e=>e.setMajorTickStyle((e=>e.setGridStrokeStyle(r))).setMinorTickStyle((e=>e.setGridStrokeStyle(r)))));h(...S.map((e=>e.axisX)));const I=f.addLegendBox(m.HorizontalLegendBox).setPosition({x:50,y:0}).setOrigin(g.CenterBottom).setMargin({bottom:30}).setDraggingMode(d.notDraggable);S.forEach((e=>I.add(e.series))),y.setNibInteractionScaleByDragging(!1).setNibInteractionScaleByWheeling(!1).setAxisInteractionZoomByWheeling(!1);const k=(e,t)=>{const n=y.getInterval(),s=n.end-n.start,o=s+.1*Math.sign(t.deltaY)*Math.abs(s);y.setInterval({start:n.end-o,end:n.end,stopAxisAfter:!1}),t.preventDefault(),t.stopPropagation()};y.onAxisInteractionAreaMouseWheel(k),S.forEach((e=>{e.chart.onSeriesBackgroundMouseWheel(k),e.series.onMouseWheel(k)})),f.addUIElement().setText("Reset").setPosition({x:0,y:0}).setOrigin(g.LeftBottom).setMargin({left:4,bottom:4}).setDraggingMode(d.notDraggable).onMouseClick((e=>{const t=S[0].series.getXMax();y.setInterval({start:t-3e4,end:t,stopAxisAfter:!1}),S.forEach((e=>e.axisY.fit()))}));const w=[{length:Math.ceil(400*Math.PI),func:e=>8*Math.sin(e/200)},{length:Math.ceil(3200*Math.PI),func:e=>7*Math.sin(e/1600)},{length:Math.ceil(800*Math.PI),func:e=>4*(Math.cos(e/400)+Math.sin(e/200))},{length:Math.ceil(800*Math.PI),func:e=>6*Math.sin(e/100)+Math.cos(e/400)},{length:Math.ceil(1800*Math.PI),func:e=>8*Math.cos(e/900)}].map((e=>{const t=[];t.length=e.length;for(let n=0;n<e.length;n+=1){const s=e.func(n);t[n]=s}return t}));let A=window.performance.now(),T=0;const b=()=>{const e=window.performance.now(),t=Math.floor(1e3*(e-A)/1e3),n=Math.min(t-T,1e3),s=[];for(let e=0;e<S.length;e++){const t=w[e%w.length],o=[];for(let e=0;e<n;e++){const n={x:1*(T+e),y:t[(T+e)%t.length]};o.push(n)}s[e]=o}S.forEach(((e,t)=>e.series.add(s[t]))),T+=n,requestAnimationFrame(b)};b();let C=window.performance.now(),B=0,P=0;const D=x.chart.getTitle(),v=()=>{B++;const e=window.performance.now();P=1e3/((e-C)/B),requestAnimationFrame(v),x.chart.setTitle(`${D} (FPS: ${P.toFixed(1)})`)};requestAnimationFrame(v),setInterval((()=>{C=window.performance.now(),B=0}),5e3)}},e=>{e.O(0,[736],(()=>(138,e(e.s=138)))),e.O()}]);